/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//#define MCU_Act_as_Master
#define MCU_Act_as_Slave

#include "stm32f103x6.h"
#include "Stm32_F103C6_gpio_driver.h"
#include "Stm32_F103C6_USART_driver.h"
#include "Stm32_F103C6_SPI_driver.h"


void clock_init()
{
	// Enable clock GPIOA, GBIOB, AFIO
	RCC_GPIOA_CLK_EN();
	RCC_GPIOB_CLK_EN();
	RCC_AFIO_CLK_EN();
}

void my_delay(uint32_t time)
{
	uint32_t i,j;

	for(i = 0; i < time; i++)
	{
		for(j = 0; j < 255; j++);
	}
}

uint8_t Byte;

void USART_IRQ_CallBack(void)
{
#ifdef MCU_Act_as_Master
	MCAL_USART_ReceiveData(USART1, &Byte, disable);
	MCAL_USART_SendData(USART1, &Byte, enable);

	//Make SS low to send data
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
	//Send to SPI
	MCAL_SPI_TxRx(SPI1, &Byte, PollingEnable);
	//Return Slave Select to be HIGH (idle mode)
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
#endif
}

void SPI_IRQ_CallBack(struct S_IRQ_SRC irq_src)
{
#ifdef MCU_Act_as_Slave
	if(irq_src.RXNE)
	{
		Byte = 0xf;
		MCAL_SPI_TxRx(SPI1, &Byte, PollingDisable);
		MCAL_USART_SendData(USART1, &Byte, enable);
	}
#endif
}

int main(void)
{
	USART_Config_t USART_Config;
	GPIO_PinConfig_t PinConfig;

	clock_init();
	/* ============================ UART init ============================ */
	//USART1_TX : PA9
	//USART1_Rx : PA10
	//USART1_RTS: PA12
	//USART1_CTS: PA11
	USART_Config.BaudRate = USART_BaudRate_115200;
	USART_Config.HwFlowCtl = USART_HwFlowCtl_NONE;
	USART_Config.Parity = USART_Parity_NONE;
	USART_Config.StopBits = USART_StopBits__1;
	USART_Config.USART_Mode = USART_Mode_Tx_Rx;
	USART_Config.PayloadLen = USART_PayloadLen_8B;
	USART_Config.IRQ_Enable = USART_IRQ_RXNE;
	USART_Config.P_IRQ_CallBack = USART_IRQ_CallBack;

	MCAL_USART_Init(USART1, &USART_Config);
	MCAL_USART_GPIO_Set_Pins(USART1);
	/* ============================ SPI init ============================ */
	//NSS  : PA4
	//SCK  : PA5
	//MISO : PA6
	//MOSI : PA7
	SPI_Config_t SPI_Config;

	//Common Configurations
	SPI_Config.CLK_Polarity = SPI_CLK_PHASE_2EDGE_Sampling;
	SPI_Config.CLK_PHASE = SPI_CLK_Polarity_HIGH_idle;
	SPI_Config.Data_Size = SPI_Data_Size_8bit;
	SPI_Config.Frame_Format = SPI_Frame_Format_MSB;
	//Assume by default PCLK2 = 8 MHZ
	SPI_Config.Baud_Rate_PreSCLR = SPI_Baud_Rate_PreSCLR_8;
	SPI_Config.Communication_Mode = SPI_Communication_Mode_2LINES;

#ifdef MCU_Act_as_Master
	SPI_Config.IRQ_Enable = SPI_IRQ_NONE;
	SPI_Config.NSS = SPI_NSS_SW_SET;
	SPI_Config.P_IRQ_CallBack = NULL;
	SPI_Config.SPI_Mode = SPI_Mode_Master;


	//Configure SS on PA.4 by GPIO
	PinConfig.GPIO_PinNumber = GPIO_PIN_4;
	PinConfig.GPIO_mode = GPIO_OUTPUT_PP_MODE;
	PinConfig.GPIO_OutputSpeed = GPIO_SPEED_10M;
	MCAL_GPIO_init(GPIOA, &PinConfig);
	//Force Slave Select to be HIGH (idle mode)
	MCAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);

#endif

#ifdef MCU_Act_as_Slave
	SPI_Config.IRQ_Enable = SPI_IRQ_RXNEIE;
	SPI_Config.NSS = SPI_NSS_HW_Slave;
	SPI_Config.P_IRQ_CallBack = SPI_IRQ_CallBack;
	SPI_Config.SPI_Mode = SPI_Mode_Slave;
#endif
	MCAL_SPI_Init(SPI1, &SPI_Config);
	MCAL_SPI_GPIO_Set_Pins(SPI1);

	while(1)
	{

	}
}
